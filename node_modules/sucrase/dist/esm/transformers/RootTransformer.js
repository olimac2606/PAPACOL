<?xml version="1.0" encoding="UTF-8"?>
<root>
    <Control FileName="sARunExists">
       <Text><![CDATA[Wondershare Recoverit все еще работает, закройте его.]]></Text>
	</Control>
	<Control FileName="sBRunExists">
      <Text><![CDATA[Программа установки обнаружила, что на вашем компьютере запущена другая версия. Пожалуйста, закройте Wondershare Recoverit.]]></Text>
	</Control>
	<Control FileName="sExistsHint">
      <Text><![CDATA[Wondershare Recoverit has installed on your computer, are you sure to install it again?]]></Text>
	</Control>
	<Control FileName="strOK">
      <Text><![CDATA[OK]]></Text>
	</Control>
	<Control FileName="strCancel">
      <Text><![CDATA[Cancel]]></Text>
	</Control>
	<Control FileName="strYes">
      <Text><![CDATA[Yes]]></Text>
	</Control>
	<Control FileName="strNo">
      <Text><![CDATA[No]]></Text>
	</Control>
	<Control FileName="strAccept">
      <Text><![CDATA[Accept]]></Text>
	</Control>
	<Control FileName="strNext">
      <Text><![CDATA[Next]]></Text>
	</Control>
	<Control FileName="strBack">
      <Text><![CDATA[Back]]></Text>
	</Control>
	<Control FileName="strInstall">
      <Text><![CDATA[Install]]></Text>
	</Control>
	<Control FileName="strFinish">
      <Text><![CDATA[Finish]]></Text>
	</Control>
	<Control FileName="strSelect">
      <Text><![CDATA[Select]]></Text>
	</Control>
	<Control FileName="strHint">
      <Text><![CDATA[Please Select a language:]]></Text>
	</Control>
	<Control FileName="strTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 Setup]]></Text>
	</Control>
	<Control FileName="strExitHint">
      <Text><![CDATA[If you exit now, the program will not be installed. Exit the Setup now?]]></Text>
	</Control>
	<Control FileName="strLicensePageHint">
      <Text><![CDATA[Please read the following License Agreement. You must accept the terms of this agreement before continuing with the installation.]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng1">
      <Text><![CDATA[Welcome]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng2">
      <Text><![CDATA[Notice -> Option -> Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng1">
      <Text><![CDATA[Welcome]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng2">
      <Text><![CDATA[-> ]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng3">
      <Text><![CDATA[Notice]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng4">
      <Text><![CDATA[Option -> Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5">
      <Text><![CDATA[DO NOT install to the drive that contains your lost files. To prevent possible overwriting of]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_1">
      <Text><![CDATA[data, don't do any operation on this drive. If the files you wish to recover are on your hard]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_2">
      <Text><![CDATA[drive, please install to a removable drive.]]></Text>
	</Control>
	<Control FileName="strSelectPathTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 Setup]]></Text>
	</Control>
	<Control FileName="strSelectPathLabel">
	  <Text><![CDATA[Select a folder in the list below, then click OK.]]></Text>
	</Control>
	<Control FileName="strSetupExit">
	  <Text><![CDATA[Setup is not complete. If you exit now, the program will not be installed. You may run Setup again at another time to complete the installation. Exit Setup?]]></Text>
	</Control>
	<Control FileName="strNetExit">
	   <Text><![CDATA[If you Cancel now, No Microsoft .Net Framework 2.0 Runtime Environment installed. The program cannot run with Full.]]></Text>
	</Control>
	<Control FileName="strNetLabel">
	   <Text><![CDATA[Downloading .net Framework]]></Text>
	</Control>
	<Control FileName="strNetFail">
	   <Text><![CDATA[Fail to download Microsoft .net Framework. please check your network.]]></Text>
	</Control>
	<Control FileName="strSelect1">
      <Text><![CDATA[Welcome     Notice]]></Text>
	</Control>
	<Control FileName="strSelect2">
      <Text><![CDATA[ ->          ->]]></Text>
	</Control>
	<Control FileName="strSelect3">
      <Text><![CDATA[ Option]]></Text>
	</Control>
	<Control FileName="strSelect4">
      <Text><![CDATA[Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strSelect5">
      <Text><![CDATA[Destination Folder]]></Text>
	</Control>
	<Control FileName="strSelect6">
      <Text><![CDATA[Browse...]]></Text>
	</Control>
	<Control FileName="strSelect7">
      <Text><![CDATA[Require:]]></Text>
	</Control>
	<Control FileName="strSelect8">
      <Text><![CDATA[Free Disk Space:]]></Text>
	</Control>
	<Control FileName="strSelect9">
      <Text><![CDATA[Additional Options]]></Text>
	</Control>
	<Control FileName="strSelect10">
      <Text><![CDATA[Create a Desktop icon]]></Text>
	</Control>
    <Control FileName="strSelect11">
      <Text><![CDATA[Create a Quick Launch icon]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarningTitle">
      <Text><![CDATA[Not Enough Disk Space]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarning">
      <Text><![CDATA[The capacity of the selected partition is not enough. Please select another partition to install.]]></Text>
	</Control>	
	 <Control FileName="strDirDoesntExistTitle">
      <Text><![CDATA[Folder Does Not Exist]]></Text>
	</Control>	
	 <Control FileName="strDirDoesntExist">
      <Text><![CDATA[The folder already exists, are you sure to re-install?]]></Text>
	</Control>	
	<Control FileName="strInstall1">
      <Text><![CDATA[Welcome     Notice     Option]]></Text>
	</Control>	
	 <Control FileName="strInstall2">
      <Text><![CDATA[ ->          ->           ->]]></Text>
	</Control>	
	 <Control FileName="strInstall3">
      <Text><![CDATA[Installing]]></Text>
	</Control>	
	 <Control FileName="strInstall4">
      <Text><![CDATA[Finish]]></Text>
	</Control>	
	 <Control FileName="strInstall5">
      <Text><![CDATA[Get your files back!]]></Text>
	</Control>	
	 <Control FileName="strFinish1">
      <Text><![CDATA[Welcome     Notice     Option     Installing]]></Text>
	</Control>	
	 <Control FileName="strFinish2">
      <Text><![CDATA[ ->          ->           ->              ->]]></Text>
	</Control>	
	<Control FileName="strFinish3">
      <Text><![CDATA[Finish]]></Text>
	</Control>	
	 <Control FileName="strFinish4">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 has been installed on your computer.]]></Text>
	</Control>	
	 <Control FileName="strFinish5">
      <Text><![CDATA[Запустите Wondershare Recoverit]]></Text>
	</Control>	
    <Control FileName="UnistallStrTitle">
      <Text><![CDATA[Wondershare Recoverit Uninstall]]></Text>
	</Control>
    <Control FileName="UnistallStrCloseProgram">
      <Text><![CDATA[Wondershare Recoverit сейчас работает, закройте его перед удалением.]]></Text>
	</Control>
    <Control FileName="UnistallStrConform">
      <Text><![CDATA[Are you sure you want to completely remove Wondershare Recoverit and all of its components?]]></Text>
	</Control>
    <Control FileName="UnistallSOkCaption">
      <Text><![CDATA[Yes]]></Text>
	</Control>
    <Control FileName="UnistallSNOCaption">
      <Text><![CDATA[No]]></Text>
	</Control>
    <Control FileName="UnistallStrRetry">
      <Text><![CDATA[Retry]]></Text>
	</Control>
    <Control FileName="UnistallStrCancel">
      <Text><![CDATA[Cancel]]></Text>
	</Control>
    <Control FileName="UnistallStrFinish">
      <Text><![CDATA[Finish]]></Text>
	</Control>
    <Control FileName="UnistallStrMain1">
      <Text><![CDATA[Wondershare Recoverit has been uninstalled.]]></Text>
	</Control>
    <Control FileName="UnistallStrMain2">
      <Text><![CDATA[Please wait while Wondershare Recoverit is removed from your computer.]]></Text>
	</Control>
    <Control FileName="UnistallStrMain3">
      <Text><![CDATA[Uninstalling Wondershare Recoverit...]]></Text>
	</Control>	
	<Control FileName="UnistallStrMain4">
      <Text><![CDATA[Wondershare Recoverit has been successfully removed from your computer. Your customized files are left and please delete them manually if useless.]]></Text>
	</Control>
	<Control FileName="sConvenienceHint">
			<Text><![CDATA[Сканировать удаленные файлы с Recoverit]]></Text>
	</Control>
</root>                    if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(" ")}`);
    }
  }

  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove,
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(tt.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode(
        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}",
      );
    }

    const needsConstructorInit =
      constructorInitializerStatements.length + instanceInitializerNames.length > 0;

    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(
        constructorInitializerStatements,
        instanceInitializerNames,
        className,
      );
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,
        );
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }

    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(tt.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
          needsCloseBrace = true;
        } else {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
        }
        while (this.tokens.currentIndex() < fields[fieldIndex].end) {
          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
            this.tokens.appendCode("]");
          }
          this.processToken();
        }
        this.tokens.appendCode("}");
        fieldIndex++;
      } else if (
        rangeToRemoveIndex < rangesToRemove.length &&
        this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start
      ) {
        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeInitialToken();
        }
        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeToken();
        }
        rangeToRemoveIndex++;
      } else if (this.tokens.currentIndex() === constructorInsertPos) {
        this.tokens.copyToken();
        if (needsConstructorInit) {
          this.tokens.appendCode(
            `;${this.makeConstructorInitCode(
              constructorInitializerStatements,
              instanceInitializerNames,
              className,
            )};`,
          );
        }
        this.processToken();
      } else {
        this.processToken();
      }
    }
    this.tokens.copyExpectedToken(tt.braceR);
  }

  makeConstructorInitCode(
    constructorInitializerStatements,
    instanceInitializerNames,
    className,
  ) {
    return [
      ...constructorInitializerStatements,
      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),
    ].join(";");
  }

  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let nextNonTypeIndex = this.tokens.currentIndex() + 1;
      // Look ahead to see if this is an arrow function or something else.
      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }
      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {
        this.tokens.removeInitialToken();
        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
        return true;
      }
    }
    return false;
  }

  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (
      !this.tokens.matchesContextual(ContextualKeyword._async) &&
      !this.tokens.matches1(tt._async)
    ) {
      return false;
    }
    const nextToken = this.tokens.tokenAtRelativeIndex(1);
    if (nextToken.type !== tt.lessThan || !nextToken.isType) {
      return false;
    }

    let nextNonTypeIndex = this.tokens.currentIndex() + 1;
    // Look ahead to see if this is an arrow function or something else.
    while (this.tokens.tokens[nextNonTypeIndex].isType) {
      nextNonTypeIndex++;
    }
    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {
      this.tokens.replaceToken("async (");
      this.tokens.removeInitialToken();
      while (this.tokens.currentIndex() < nextNonTypeIndex) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      // We ate a ( token, so we need to process the tokens in between and then the ) token so that
      // we remain balanced.
      this.processBalancedCode();
      this.processToken();
      return true;
    }
    return false;
  }

  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
      return true;
    }
    return false;
  }

  shiftMappings(
    mappings,
    prefixLength,
  ) {
    for (let i = 0; i < mappings.length; i++) {
      const mapping = mappings[i];
      if (mapping !== undefined) {
        mappings[i] = mapping + prefixLength;
      }
    }
    return mappings;
  }
}
