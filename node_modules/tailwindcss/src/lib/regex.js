export as namespace async;

export interface Dictionary<T> {
    [key: string]: T;
}
export type IterableCollection<T> = T[] | IterableIterator<T> | AsyncIterable<T> | Dictionary<T>;

export interface ErrorCallback<E = Error> {
    (err?: E | null): void;
}
export interface AsyncBooleanResultCallback<E = Error> {
    (err?: E | null, truthValue?: boolean): void;
}
export interface AsyncResultCallback<T, E = Error> {
    (err?: E | null, result?: T): void;
}
export interface AsyncResultArrayCallback<T, E = Error> {
    (err?: E | null, results?: Array<T | undefined>): void;
}
export interface AsyncResultObjectCallback<T, E = Error> {
    (err: E | undefined, results: Dictionary<T | undefined>): void;
}
export interface AsyncResultRestCallback<T, E = Error> {
    (err?: E | null, ...results: T[]): void;
}

export interface AsyncFunction<T, E = Error> {
    (callback: (err?: E | null, result?: T) => void): void;
}
export interface AsyncFunctionEx<T, E = Error> {
    (callback: (err?: E | null, ...results: T[]) => void): void;
}
export interface AsyncIterator<T, E = Error> {
    (item: T, callback: ErrorCallback<E>): void;
}
export interface AsyncForEachOfIterator<T, E = Error> {
    (item: T, key: number | string, callback: ErrorCallback<E>): void;
}
export interface AsyncResultIterator<T, R, E = Error> {
    (item: T, callback: AsyncResultCallback<R, E>): void;
}
export interface AsyncResultIteratorPromise<T, R> {
    (item: T): Promise<R>;
}
export interface AsyncMemoIterator<T, R, E = Error> {
    (memo: R | undefined, item: T, callback: AsyncResultCallback<R, E>): void;
}
export interface AsyncBooleanIterator<T, E = Error> {
    (item: T, callback: AsyncBooleanResultCallback<E>): void;
}

export interface AsyncWorker<T, E = Error> {
    (task: T, callback: ErrorCallback<E>): void;
}
export interface AsyncVoidFunction<E = Er