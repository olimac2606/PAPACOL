"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    updateAllClasses: function() {
        return updateAllClasses;
    },
    asValue: function() {
        return asValue;
    },
    parseColorFormat: function() {
        return parseColorFormat;
    },
    asColor: function() {
        return asColor;
    },
    asLookupValue: function() {
        return asLookupValue;
    },
    typeMap: function() {
        return typeMap;
    },
    coerceValue: function() {
        return coerceValue;
    },
    getMatchingTypes: function() {
        return getMatchingTypes;
    }
});
const _escapeCommas = /*#__PURE__*/ _interop_require_default(require("./escapeCommas"));
const _withAlphaVariable = require("./withAlphaVariable");
const _dataTypes = require("./dataTypes");
const _negateValue = /*#__PURE__*/ _interop_require_default(require("./negateValue"));
const _validateFormalSyntax = require("./validateFormalSyntax");
const _featureFlags = require("../featureFlags.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel)=>{
        sel.value = updateClass(sel.value);
        if (sel.raws && sel.raws.value) {
            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
        }
    });
}
function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
        return undefined;
    }
    let value = modifier.slice(1, -1);
    if (!validate(value)) {
        return undefined;
    }
    return (0, _dataTypes.normalize)(value);
}
function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== undefined) {
        return (0, _negateValue.default)(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === undefined) {
            return undefined;
        }
        return (0, _negateValue.default)(resolved);
    }
}
function asValue(modifier, options = {}, { validate =()=>true  } = {}) {
    var _options_values;
    let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
    if (value !== undefined) {
        return value;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
        return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
}
function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
}
function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    // If the `/` is inside an arbitrary, we want to find the previous one if any
    // This logic probably isn't perfect but it should work for most cases
    let arbitraryStartIdx = modifier.lastIndexOf("[", slashIdx);
    let arbitraryEndIdx = modifier.indexOf("]", slashIdx);
    let isNextToArbitrary = modifier[slashIdx - 1] === "]" || modifier[slashIdx + 1] === "[";
    // Backtrack to the previous `/` if the one we found was inside an arbitrary
    if (!isNextToArbitrary) {
        if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {
            if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {
                slashIdx = modifier.lastIndexOf("/", arbitraryStartIdx);
            }
        }
    }
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
            modifier,
            undefined
        ];
    }
    let arbitrary = isArbitraryValue(modifier);
    // The modifier could be of the form `[foo]/[bar]`
    // We want to handle this case properly
    // without affecting `[foo/bar]`
    if (arbitrary && !modifier.includes("]/[")) {
        return [
            modifier,
            undefined
        ];
    }
    return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
    ];
}
function parseColorFormat(value) {
    if (typeof value === "string" && value.includes("<alpha-value>")) {
        let oldValue = value;
        return ({ opacityValue =1  })=>oldValue.replace(/<alpha-value>/g, opacityValue);
    }
    return value;
}
function unwrapArbitraryModifier(modifier) {
    return (0, _dataTypes.normalize)(modifier.slice(1, -1));
}
function asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {
    var _options_values;
    if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {
        var _options_values1;
        return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);
    }
    // TODO: Hoist this up to getMatchingTypes or something
    // We do this here because we need the alpha value (if any)
    let [color, alpha] = splitUtilityModifier(modifier);
    if (alpha !== undefined) {
        var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;
        var _options_values_color;
        let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;
        if (normalizedColor === undefined) {
            return undefined;
        }
        normalizedColor = parseColorFormat(normalizedColor);
        if (isArbitraryValue(alpha)) {
            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));
        }
        if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {
            return undefined;
        }
        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, options, {
        validate: _dataTypes.color
    });
}
function asLookupValue(modifier, options = {}) {
    var _options_values;
    return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
}
function guess(validate) {
    return (modifier, options)=>{
        return asValue(modifier, options, {
            validate
        });
    };
}
let typeMap = {
    any: asValue,
    color: asColor,
    url: guess(_dataTypes.url),
    image: guess(_dataTypes.image),
    length: guess(_dataTypes.length),
    percentage: guess(_dataTypes.percentage),
    position: guess(_dataTypes.position),
    lookup: asLookupValue,
    "generic-name": guess(_dataTypes.genericName),
    "family-name": guess(_dataTypes.familyName),
    number: guess(_dataTypes.number),
    "line-width": guess(_dataTypes.lineWidth),
    "absolute-size": guess(_dataTypes.absoluteSize),
    "relative-size": guess(_dataTypes.relativeSize),
    shadow: guess(_dataTypes.shadow),
    size: guess(_validateFormalSyntax.backgroundSize)
};
let supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1) return [
        undefined,
        input
    ];
    return [
        input.slice(0, idx),
        input.slice(idx + 1)
    ];
}
function coerceValue(types, modifier, options, tailwindConfig) {
    if (options.values && modifier in options.values) {
        for (let { type  } of types !== null && types !== void 0 ? types : []){
            let result = typeMap[type](modifier, options, {
                tailwindConfig
            });
            if (result === undefined) {
                continue;
            }
            return [
                result,
 <¸dÊïœ•Í!¿`¡½ÝB   ð Ø5  ² Ø5  c Hºÿ   4 Hºÿ  y L7ü   Þ L7ü  / Vö¯   Vö¯  Ç \ú¿  Ô \ú¿  Y"î>  ve  	¿jì“  Ýjì“  ’””>  ¬@ä   §¬@ä  ô‰ð…    ‰ð…  AšÛ.  	r§Œ5   b§Œ5  «
5Ž#  x
5Ž#  ù
B1…  e
ò  <
ò  Î    ‹åØ~  µi  
    A r c h i v e       Archive   
CommonFunc   
 A u d i o       Audio   
CommonFunc    B a s e   d e   d o n n é e s       Database   
CommonFunc    D o c u m e n t       Document   
CommonFunc    E - m a i l       Email   
CommonFunc   & F i c h i e r   s a n s   c h e m i n       File lost location   
CommonFunc     F i c h i e r   s a n s   n o m       File lost name   
CommonFunc    J e u x       Game   
CommonFunc    A u t r e s       Others   
CommonFunc   
 P h o t o       Photo   
CommonFunc    C o r b e i l l e       Recycle Bin   
CommonFunc   0 F i c h i e r s   n o n   e n r e g i s t r é s       Unsaved files   
CommonFunc   
 V i d é o       Video   
CommonFunc    F i c h i e r s   W e b       Webfiles   
CommonFunc    A r c h i v e       Archive   CommonFunction   
 A u d i o       Audio   CommonFunction    B a s e   d e   d o n n é e s       Database   CommonFunction    D o c u m e n t       Document   CommonFunction    E - m a i l       Email   CommonFunction    J e u x       Game   CommonFunction    A u t r e s       Others   CommonFunction   
 P h o t o       Photo   CommonFunction   0 F i c h i e r s   n o n   e n r e g i s t r é s       Unsaved files   CommonFunction   
 V i d é o       Video   CommonFunction    F i c h i e r s   W e b       Webfiles   CommonFunction    C o r b e i l l e       Recycle Bin   TreeDataManager   C e s   f i c h i e r s   n ' o n t   a u c u n e   i n f o r m a t i o n   s u r   l e u r   c h e m i n   d e   s t o c k a g e   d ' o r i g i n e ,   v o u s   p o u v e z   v é r i f i e r   s ' i l s   s o n t   b i e n   c e u x   q u e   v o u s   c h e r c h e z .       oThese files have no information about their original storage path, you may check to see if it is what you need.   TreeItemDelegate    C e s   f i c h i e r s   n ' o n t   p l u s   l e u r s   n o m s   d e   f i c h i e r s ,   l e u r s   t a i l l e s   e t   l e u r s   h o r o d a t a g e s   d ' o r i g i n e .   M a i s   i l s   s o n t   p r o b a b l e m e n t   c e u x   q u e   v o u s   c h e r c h e z .       xThese files no longer have their original file names, file sizes and time stamps. But they may be exactly what you need.   TreeItemDelegate    R é p e r t o i r e       File Location   TreeViewMainWidgetClass    T y p e   d e   F i c h i e r       	File Type   TreeViewMainWidgetClassˆ                                                                                                                         