"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return expandTailwindAtRules;
    }
});
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _quicklru = /*#__PURE__*/ _interop_require_default(require("@alloc/quick-lru"));
const _sharedState = /*#__PURE__*/ _interop_require_wildcard(require("./sharedState"));
const _generateRules = require("./generateRules");
const _log = /*#__PURE__*/ _interop_require_default(require("../util/log"));
const _cloneNodes = /*#__PURE__*/ _interop_require_default(require("../util/cloneNodes"));
const _defaultExtractor = require("./defaultExtractor");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let env = _sharedState.env;
const builtInExtractors = {
    DEFAULT: _defaultExtractor.defaultExtractor
};
const builtInTransformers = {
    DEFAULT: (content)=>content,
    svelte: (content)=>content.replace(/(?:^|\s)class:/g, " ")
};
function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}
function getTransformer(tailwindConfig, fileExtension) {
    let transformers = tailwindConfig.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}
let extractorCache = new WeakMap();
// Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.
function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
        extractorCache.set(extractor, new _quicklru.default({
            maxSize: 25000
        }));
    }
    for (let line of content.split("\n")){
        line = line.trim();
        if (seen.has(line)) {
            continue;
        }
        seen.add(line);
        if (extractorCache.get(extractor).has(line)) {
            for (let match of extractorCache.get(extractor).get(line)){
                candidates.add(match);
            }
        } else {
            let extractorMatches = extractor(line).filter((s)=>s !== "!*");
            let lineMatchesSet = new Set(extractorMatches);
            for (let match of lineMatchesSet){
                candidates.add(match);
            }
            extractorCache.get(extractor).set(line, lineMatchesSet);
        }
    }
}
/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */ function buildStylesheet(rules, context) {
    let sortedRules = context.offsets.sort(rules);
    let returnValue = {
        base: new Set(),
        defaults: new Set(),
        components: new Set(),
        utilities: new Set(),
        variants: new Set()
    };
    for (let [sort, rule] of sortedRules){
        returnValue[sort.layer].add(rule);
    }
    return returnValue;
}
function expandTailwindAtRules(context) {
    return async (root)=>{
        let layerNodes = {
            base: null,
            components: null,
            utilities: null,
            variants: null
        };
        root.walkAtRules((rule)=>{
            // Make sure this file contains Tailwind directives. If not, we can save
            // a lot of work and bail early. Also we don't have to register our touch
            // file as a dependency since the output of this CSS does not depend on
            // the source of any templates. Think Vue <style> blocks for example.
            if (rule.name === "tailwind") {
                if (Object.keys(layerNodes).includes(rule.params)) {
                    layerNodes[rule.params] = rule;
                }
            }
        });
        if (Object.values(layerNodes).every((n)=>n === null)) {
            return root;
        }
        var _context_candidates;
        // ---
        // Find potential rules in changed files
        let candidates = new Set([
            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],
            _sharedState.NOT_ON_DEMAND
        ]);
        let seen = new Set();
        env.DEBUG && console.time("Reading changed files");
        /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */ let regexParserContent = [];
        for (let item of context.changedContent){
            let transformer = getTransformer(context.tailwindConfig, item.extension);
            let extractor = getExtractor(context, item.extension);
            regexParserContent.push([
                item,
                {
                    transformer,
                    extractor
                }
            ]);
        }
        const BATCH_SIZE = 500;
        for(let i = 0; i < regexParserContent.length; i += BATCH_SIZE){
            let batch = regexParserContent.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(async ([{ file , content  }, { transformer , extractor  }])=>{
                content = file ? await _fs.default.promises.readFile(file, "utf8") : content;
                getClassCandidates(transformer(content), extractor, candidates, seen);
            }));
        }
        env.DEBUG && console.timeEnd("Reading changed files");
        // ---
        // Generate the actual CSS
        let classCacheCount = context.classCache.size;
        env.DEBUG && console.time("Generate rules");
        env.DEBUG && console.time("Sorting candidates");
        let sortedCandidates = new Set([
            ...candidates
        ].sort((a, z)=>{
            if (a === z) return 0;
            if (a < z) return -1;
            return 1;
        }));
        env.DEBUG && console.timeEnd("Sorting candidates");
        (0, _generateRules.generateRules)(sortedCandidates, context);
        env.DEBUG && console.timeEnd("Generate rules");
        // We only ever add to the classCache, so if it didn't grow, there is nothing new.
        env.DEBUG && console.time("Build stylesheet");
        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
            context.stylesheetCache = buildStylesheet([
                ...context.ruleCache
            ], context);
        }
        env.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;
        // ---
€ ` ĞAILõ“ P€Ô–˜@H 0@4‘ø{   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=0, PID=1650 	rocName =cmd.exe,- 'iswin dowed So urce=-1)  success1Ä	ĞÉ 3ÂP  }q°ÿsı

,cA€ õß‚6€Ôğ­â1ö˜  y™‚¡E‹…;÷ƒ' \\.\DIÀSPLAY1…	ÿ Á'    H  ± @   "N  €$€€ ` ĞAœ¹J” P€Ô–˜@H 0@4‘@~   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=6584 ,ProcNam e=explor€er.exe,1 =0,iswin dowed So urce=-1)  success`  Ø ˜ĞÉ3ÂP }qÿØsı

,c€  õß‚6€Ô­øâ1ö˜  y‚Ì¡E‹…;÷ƒ' \\.\DISàPLAY1…	ÿ Á\  P  H  M± @   "N  €$€€ ` ĞA±Œ$• P€Ô–˜@H 0@4‘ˆ€   , x  IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=_uni nstall18@276.00 A ppWindow€Width=5aHeight =393, Mo nitor&192 ;%108 ¢s¢{_DCS/SizeDiv
bIs
ed=,0)v€Œ,Œôß‚6	 øƒ  .ÂPƒvw€vxı ‚›‰€   8‡P*/„‰×ÿ¡HÂ'cUÅ'à><Â%Á*    H  ± @   "N  €$€€ ` ĞAW$• P€Ô–˜@H 0@4‘Ğ‚   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=6752 ,ProcNam e=_unins tall1827@6.000,8= 0,iswindowed Sou rce=-1) €successšĞÉ3ÂP € }qÿsı
,c€	 õß‚‚6€Ô­â1ö˜Ï  y‚¡E‹…;÷ƒ' \\. \DISPLAY1…	ÿ Á\  P  H  M± @   "N  €$€€ ` ĞA&ÊU– P€Ô–˜@H 0@4‘…   , x  IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=_uni nstall18@276.00 A ppWindow€Width=5aHeight =393, Mo nitor&192 ;%108 ¢s¢{_DCS/SizeDiv
bIs
ed=,0)v€Œ,Œôß‚6	 øƒ  .ÂPƒvw€vxı ‚›‰€   8‡P*/„‰×ÿ¡HÂ'cUÅ' @<Â%Á&    H  ± @   "N  €$€€ ` ĞA×ÊU– P€Ô–˜@H 0@4‘`‡   , FullSc reenDete ctThread (): Notify>s>(Ev ent=0,PI D=6752,P rocName= _uninsta ll18276.0000,8 2is windowed Source= -1) success ‡ĞÉ3 ÂP  }qÿØsı
,c€	  õß‚6€Ô­¸â1ö˜ Ì¡E‹…;÷ƒ'  \\.\DISàPLAY1…	ÿ Á(    H  ± @   "N  €$€€ ` ĞAäWß– P€Ô–˜@H 0@4‘¨‰   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=2728 ,ProcNam e=explor€er.exe,1 =0,iswin dowed So urce=-1)  success`  p˜Ğ É3ÂP  }`qÿsı

,ƒc€ õß‚6€àÔ­â1ö˜ 3 y‚¡E‹…;÷ƒ' \\.\D€ISPLAY1…	ÿ Á'    H  ± @   "N  €$€€ ` ĞAãÌq— P€Ô–˜@H 0@4‘ğ‹   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=6584 ,ProcNam e=explor€er.exe,1 =0,iswin dowed So urce=-1)  success`  Ø ˜ĞÉ3ÂP }qÿØsı

,c€  õß‚6€Ô­øâ1ö˜  y‚Ì¡E‹…;÷ƒ' \\.\DISàPLAY1…	ÿ ÁU  I  H  F± @   "N  €$€€ ` ĞAö-{— P€Ô–˜@H 0@4‘8   , x  IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=msed ge.exe,  AppWindo wWidth=192 )aHei ght=1032 , Monitonr	(&8 <›sC›t_DCS`S@izeDiv
bIs
ed=0)À ù’ÂPƒuZŒØ€yŒôß‚6 øƒ  .„#ƒvw€ğvı ‚›!‰@€  8‡P*/ŠC‰é‘#ÄÁCÁAÁ'ğ?<Â%Á'    H  ± @   "N  €$€€ ` ĞA.{— P€Ô–˜@H 0@4‘€   , x  Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1072 4,ProcNa me=msedg@e.exe,0= 0,iswindowed Sou rce=-1) €success ‰Ô ĞÉ3 ÂP  }qÿØsı

,c€  õß‚6€Ô­øâ1ö˜  y‚Ì¡E‹…;÷ƒ' \\.\DISàPLAY1…	ÿ ÁU  I  H  F± @   "N  €$€€ ` ĞA_.­˜ P€Ô–˜@H 0@4‘È’   , x  IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=msed ge.exe,  AppWindo wWidth=192 )aHei ght=1032 , Monitonr	(&8 <›sC›t_DCS`S@izeDiv
bIs
ed=0)À ù’ÂPƒuZŒô€yŒôß‚6 øƒ  .„#ƒvw€ğvı ‚›!‰@€  8‡P*/ŠC‰éğ‹#ÄÁCÁAÁ'><Â%Á%    H  ± @   "N  €$€€ ` ĞA/­˜ P€Ô–˜@H 0@4‘•   , x  Full ScreenDe tectThre ad():