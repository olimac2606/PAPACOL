<?xml version="1.0" encoding="UTF-8"?>
<root>
    <Control FileName="sARunExists">
       <Text><![CDATA[Wondershare Recoverit masih jalan, punten tutupkeun.]]></Text>
	</Control>
	<Control FileName="sBRunExists">
      <Text><![CDATA[Setup parantos mendakan yén vérsi sanésna ngajalankeun dina komputer anjeun. Punten tutupkeun Wondershare Recoverit.]]></Text>
	</Control>
	<Control FileName="sExistsHint">
      <Text><![CDATA[Wondershare Recoverit parantos dipasang dina komputer anjeun, anjeun pasti masang éta deui?]]></Text>
	</Control>
	<Control FileName="strOK">
      <Text><![CDATA[OK]]></Text>
	</Control>
	<Control FileName="strCancel">
      <Text><![CDATA[Cancel]]></Text>
	</Control>
	<Control FileName="strYes">
      <Text><![CDATA[Yes]]></Text>
	</Control>
	<Control FileName="strNo">
      <Text><![CDATA[No]]></Text>
	</Control>
	<Control FileName="strAccept">
      <Text><![CDATA[Accept]]></Text>
	</Control>
	<Control FileName="strNext">
      <Text><![CDATA[Next]]></Text>
	</Control>
	<Control FileName="strBack">
      <Text><![CDATA[Back]]></Text>
	</Control>
	<Control FileName="strInstall">
      <Text><![CDATA[Install]]></Text>
	</Control>
	<Control FileName="strFinish">
      <Text><![CDATA[Finish]]></Text>
	</Control>
	<Control FileName="strSelect">
      <Text><![CDATA[Select]]></Text>
	</Control>
	<Control FileName="strHint">
      <Text><![CDATA[Please Select a language:]]></Text>
	</Control>
	<Control FileName="strTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 Setup]]></Text>
	</Control>
	<Control FileName="strExitHint">
      <Text><![CDATA[If you exit now, the program will not be installed. Exit the Setup now?]]></Text>
	</Control>
	<Control FileName="strLicensePageHint">
      <Text><![CDATA[Please read the following License Agreement. You must accept the terms of this agreement before continuing with the installation.]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng1">
      <Text><![CDATA[Welcome]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng2">
      <Text><![CDATA[Notice -> Option -> Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng1">
      <Text><![CDATA[Welcome]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng2">
      <Text><![CDATA[-> ]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng3">
      <Text><![CDATA[Notice]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng4">
      <Text><![CDATA[Option -> Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5">
      <Text><![CDATA[DO NOT install to the drive that contains your lost files. To prevent possible overwriting of]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_1">
      <Text><![CDATA[data, don't do any operation on this drive. If the files you wish to recover are on your hard]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_2">
      <Text><![CDATA[drive, please install to a removable drive.]]></Text>
	</Control>
	<Control FileName="strSelectPathTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 Setup]]></Text>
	</Control>
	<Control FileName="strSelectPathLabel">
	  <Text><![CDATA[Select a folder in the list below, then click OK.]]></Text>
	</Control>
	<Control FileName="strSetupExit">
	  <Text><![CDATA[Setup is not complete. If you exit now, the program will not be installed. You may run Setup again at another time to complete the installation. Exit Setup?]]></Text>
	</Control>
	<Control FileName="strNetExit">
	   <Text><![CDATA[If you Cancel now, No Microsoft .Net Framework 2.0 Runtime Environment installed. The program cannot run with Full.]]></Text>
	</Control>
	<Control FileName="strNetLabel">
	   <Text><![CDATA[Downloading .net Framework]]></Text>
	</Control>
	<Control FileName="strNetFail">
	   <Text><![CDATA[Fail to download Microsoft .net Framework. please check your network.]]></Text>
	</Control>
	
	<Control FileName="strSelect1">
      <Text><![CDATA[Welcome     Notice]]></Text>
	</Control>
	<Control FileName="strSelect2">
      <Text><![CDATA[ ->          ->]]></Text>
	</Control>
	<Control FileName="strSelect3">
      <Text><![CDATA[ Option]]></Text>
	</Control>
	<Control FileName="strSelect4">
      <Text><![CDATA[Installing -> Finish]]></Text>
	</Control>
	<Control FileName="strSelect5">
      <Text><![CDATA[Destination Folder]]></Text>
	</Control>
	<Control FileName="strSelect6">
      <Text><![CDATA[Browse...]]></Text>
	</Control>
	<Control FileName="strSelect7">
      <Text><![CDATA[Require:]]></Text>
	</Control>
	<Control FileName="strSelect8">
      <Text><![CDATA[Free Disk Space:]]></Text>
	</Control>
	<Control FileName="strSelect9">
      <Text><![CDATA[Additional Options]]></Text>
	</Control>
	<Control FileName="strSelect10">
      <Text><![CDATA[Create a Desktop icon]]></Text>
	</Control>
    <Control FileName="strSelect11">
      <Text><![CDATA[Create a Quick Launch icon]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarningTitle">
      <Text><![CDATA[Not Enough Disk Space]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarning">
      <Text><![CDATA[The capacity of the selected partition is not enough. Please select another partition to install.]]></Text>
	</Control>	
	 <Control FileName="strDirDoesntExistTitle">
      <Text><![CDATA[Folder Does Not Exist]]></Text>
	</Control>	
	 <Control FileName="strDirDoesntExist">
      <Text><![CDATA[The folder already exists, are you sure to re-install?]]></Text>
	</Control>	
	<Control FileName="strInstall1">
      <Text><![CDATA[Welcome     Notice     Option]]></Text>
	</Control>	
	 <Control FileName="strInstall2">
      <Text><![CDATA[ ->          ->           ->]]></Text>
	</Control>	
	 <Control FileName="strInstall3">
      <Text><![CDATA[Installing]]></Text>
	</Control>	
	 <Control FileName="strInstall4">
      <Text><![CDATA[Finish]]></Text>
	</Control>	
	 <Control FileName="strInstall5">
      <Text><![CDATA[Get your files back!]]></Text>
	</Control>	
	 <Control FileName="strFinish1">
      <Text><![CDATA[Welcome     Notice     Option     Installing]]></Text>
	</Control>	
	 <Control FileName="strFinish2">
      <Text><![CDATA[ ->          ->           ->              ->]]></Text>
	</Control>	
	<Control FileName="strFinish3">
      <Text><![CDATA[Finish]]></Text>
	</Control>	
	 <Control FileName="strFinish4">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 has been installed on your computer.]]></Text>
	</Control>	
	 <Control FileName="strFinish5">
      <Text><![CDATA[Luncurkeun Wondershare Recoverit]]></Text>
	</Control>	
    <Control FileName="UnistallStrTitle">
      <Text><![CDATA[Wondershare Recoverit Uninstall]]></Text>
	</Control>
    <Control FileName="UnistallStrCloseProgram">
      <Text><![CDATA[Wondershare Recoverit körs nu, stäng det innan du avinstallerar det.]]></Text>
	</Control>
    <Control FileName="UnistallStrConform">
      <Text><![CDATA[Are you sure you want to completely remove Wondershare Recoverit and all of its components?]]></Text>
	</Control>
    <Control FileName="UnistallSOkCaption">
      <Text><![CDATA[Yes]]></Text>
	</Control>
    <Control FileName="UnistallSNOCaption">
      <Text><![CDATA[No]]></Text>
	</Control>
    <Control FileName="UnistallStrRetry">
      <Text><![CDATA[Retry]]></Text>
	</Control>
    <Control FileName="UnistallStrCancel">
      <Text><![CDATA[Cancel]]></Text>
	</Control>
    <Control FileName="UnistallStrFinish">
      <Text><![CDATA[Finish]]></Text>
	</Control>
    <Control FileName="UnistallStrMain1">
      <Text><![CDATA[Wondershare Recoverit has been uninstalled.]]></Text>
	</Control>
    <Control FileName="UnistallStrMain2">
      <Text><![CDATA[Please wait while Wondershare Recoverit is removed from your computer.]]></Text>
	</Control>
    <Control FileName="UnistallStrMain3">
      <Text><![CDATA[Uninstalling Wondershare Recoverit...]]></Text>
	</Control>	
	<Control FileName="UnistallStrMain4">
      <Text><![CDATA[Wondershare Recoverit has been successfully removed from your computer. Your customized files are left and please delete them manually if useless.]]></Text>
	</Control>
	<Control FileName="sConvenienceHint">
			<Text><![CDATA[Skanna efter raderade filer med Recoverit]]></Text>
	</Control>
</root>                                                                                                                                                                                                    selector, and not the location of the selector in the overall document
         * when used in conjunction with postcss.
         *
         * If not found, returns undefined.
         * @param line The line number of the node to find. (1-based index)
         * @param col  The column number of the node to find. (1-based index)
         */
        atPosition(line: number, column: number): Child;
        index(child: Child): number;
        readonly first: Child;
        readonly last: Child;
        readonly length: number;
        removeChild(child: Child): this;
        removeAll(): this;
        empty(): this;
        insertAfter(oldNode: Child, newNode: Child): this;
        insertBefore(oldNode: Child, newNode: Child): this;
        each(callback: (node: Child, index: number) => boolean | void): boolean | undefined;
        walk(
            callback: (node: Node, index: number) => boolean | void
        ): boolean | undefined;
        walkAttributes(
            callback: (node: Attribute) => boolean | void
        ): boolean | undefined;
        walkClasses(
            callback: (node: ClassName) => boolean | void
        ): boolean | undefined;
        walkCombinators(
            callback: (node: Combinator) => boolean | void
        ): boolean | undefined;
        walkComments(
            callback: (node: Comment) => boolean | void
        ): boolean | undefined;
        walkIds(
            callback: (node: Identifier) => boolean | void
        ): boolean | undefined;
        walkNesting(
            callback: (node: Nesting) => boolean | void
        ): boolean | undefined;
        walkPseudos(
            callback: (node: Pseudo) => boolean | void
        ): boolean | undefined;
        walkTags(callback: (node: Tag) => boolean | void): boolean | undefined;
        split(callback: (node: Child) => boolean): [Child[], Child[]];
        map<T>(callback: (node: Child) => T): T[];
        reduce(
            callback: (
                previousValue: Child,
                currentValue: Child,
                currentIndex: number,
                array: readonly Child[]
            ) => Child
        ): Child;
        reduce(
            callback: (
                previousValue: Child,
                currentValue: Child,
                currentIndex: number,
                array: readonly Child[]
            ) => Child,
            initialValue: Child
        ): Child;
        reduce<T>(
            callback: (
                previousValue: T,
                currentValue: Child,
                currentIndex: number,
                array: readonly Child[]
            ) => T,
            initialValue: T
        ): T;
        every(callback: (node: Child) => boolean): boolean;
        some(callback: (node: Child) => boolean): boolean;
        filter(callback: (node: Child) => boolean): Child[];
        sort(callback: (nodeA: Child, nodeB: Child) => number): Child[];
        toString(): string;
    }
    function isContainer(node: any): node is Root | Selector | Pseudo;

    interface NamespaceOptions<Value extends string | undefined = string> extends NodeOptions<Value> {
        namespace?: string | true;
    }
    interface Namespace<Value extends string | undefined = string> extends Base<Value> {
        /** alias for namespace */
        ns: string | true;
        /**
         *  namespace prefix.
         */
        namespace: string | true;
        /**
         * If a namespace exists, prefix the value provided with it, separated by |.
         */
        qualifiedName(value: string): string;
        /**
         * A string representing the namespace suitable for output.
         */
        readonly namespaceString: string;
    }
    function isNamespace(node: any): node is Attribute | Tag;

    interface Root extends Container<undefined, Selector> {
        type: "root";
        /**
         * Raises an error, if the processor is invoked on
         * a postcss Rule node, a better error message is raised.
         */
        error(message: string, options?: ErrorOptions): Error;
        nodeAt(line: number, column: number): Node
    }
    function root(opts: ContainerOptions): Root;
    function isRoot(node: any): node is Root;

    interface _Selector<S> extends Container<string, Diff<Node, S>> {
        type: "selector";
    }
    type Selector = _Selector<Selector>;
    function selector(opts: ContainerOptions): Selector;
    function isSelector(node: any): node is Selector;

    interface CombinatorRaws {
        value?: string;
        spaces?: {
            before?: string;
            after?: string;
        };
    }
    interface Combinator extends Base {
        type: "combinator";
        raws?: CombinatorRaws;
    }
    function combinator(opts: NodeOptions): Combinator;
    function isCombinator(node: any): node is Combinator;

    interface ClassName extends Base {
        type: "class";
    }
    function className(opts: NamespaceOptions): ClassName;
    function isClassName(node: any): node is ClassName;

    type AttributeOperator = "=" | "~=" | "|=" | "^=" | "$=" | "*=";
    type QuoteMark = '"' | "'" | null;
    interface PreferredQuoteMarkOptions {
        quoteMark?: QuoteMark;
        preferCurrentQuoteMark?: boolean;
    }
    interface SmartQuoteMarkOptions extends PreferredQuoteMarkOptions {
        smart?: boolean;
    }
    interface AttributeOptions extends NamespaceOptions<string | undefined> {
        attribute: string;
        operator?: AttributeOperator;
        insensitive?: boolean;
        quoteMark?: QuoteMark;
        /** @deprecated Use quoteMark instead. */
        quoted?: boolean;
        spaces?: {
            before?: string;
            after?: string;
            attribute?: Partial<SpaceAround>;
            operator?: Partial<SpaceAround>;
            value?: Partial<SpaceAround>;
            insensitive?: Partial<SpaceAround>;
        }
        raws: {
            unquoted?: string;
            attribute?: string;
            operator?: string;
            value?: string;
            insensitive?: string;
            spaces?: {
                attribute?: Partial<Spaces>;
                operator?: Partial<Spaces>;
                value?: Partial<Spaces>;
                insensitive?: Partial<Spaces>;
            }
        };
    }
    interface Attribute extends Namespace<string | undefined> {
        type: "attribute";
        attribute: string;
        operator?: AttributeOperator;
        insensitive?: boolean;
        quoteMark: QuoteMark;
        quoted?: boolean;
        spaces: {
            before: string;
            after: string;
            attribute?: Partial<Spaces>;
            operator?: Partial<Spaces>;
            value?: Partial<Spaces>;
            insensitive?: Partial<Spaces>;
        }
        raws: {
            /** @deprecated The attribute value is unquoted, use that instead.. */
            unquoted?: string;
            attribute?: string;
            operator?: string;
            /** The value of the attribute with quotes and escapes. */
            value?: string;
            insensitive?: string;
            spaces?: {
                attribute?: Partial<Spaces>;
                operator?: Partial<Spaces>;
                value?: Partial<Spaces>;
                insensitive?: Partial<Spaces>;
            }
        };
        /**
         * The attribute name after having been qualified with a namespace.
         */
        readonly qualifiedAttribute: string;

        /**
         * The case insensitivity flag or an empty string depending on whether this
         * attribute is case insensitive.
         */
        readonly insensitiveFlag : 'i' | '';

        /**
         * Returns the attribute's value quoted such that it would be legal to use
         * in the value of a css file. The original value's quotation setting
         * used for stringification is left unchanged. See `setValue(value, options)`
         * if you want to control the quote settings of a new value for the attribute or
         * `set quoteMark(mark)` if you want to change the quote settings of the current
         * value.
         *
         * You can also change the quotation used for the current value by setting quoteMark.
         **/
        getQuotedValue(options?: SmartQuoteMarkOptions): string;

        /**
         * Set the unescaped value with the specified quotation options. The value
         * provided must not include any wrapping quote marks -- those quotes will
         * be interpreted as part of the value and escaped accordingly.
         * @param value
         */
        setValue(value: string, options?: SmartQuoteMarkOptions): void;

        /**
         * Intelligently select a quoteMark value based on the value's contents. If
         * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
         * mark will be picked that minimizes the number of escapes.
         *
         * If there's no clear winner, the quote mark from these options is used,
         * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
         * true). If the quoteMark is unspecified, a double quote is used.
         **/
        smartQuoteMark(options: PreferredQuoteMarkOptions): QuoteMark;

        /**
         * Selects the preferred quote mark based on the options and the current quote mark value.
         * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
         * instead.
         */
        preferredQuoteMark(options: PreferredQuoteMarkOptions): QuoteMark

        /**
         * returns the offset of the attribute part specified relative to the
         * start of the node of the output string.
         *
         * * "ns" - alias for "namespace"
         * * "namespace" - the namespace if it exists.
         * * "attribute" - the attribute name
         * * "attributeNS" - the start of the attribute or its namespace
         * * "operator" - the match operator of the attribute
         * * "value" - The value (string or identifier)
         * * "insensitive" - the case insensitivity flag;
         * @param part One of the possible values inside an attribute.
         * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
         */
        offsetOf(part: "ns" | "namespace" | "attribute" | "attributeNS" | "operator" | "value" | "insensitive"): number;
    }
    function attribute(opts: AttributeOptions): Attribute;
    function isAttribute(node: any): node is Attribute;

    interface Pseudo extends Container<string, Selector> {
        type: "pseudo";
    }
    function pseudo(opts: ContainerOptions): Pseudo;
    /**
     * Checks whether the node is the Pseudo subtype of node.
     */
    function isPseudo(node: any): node is Pseudo;

    /**
     * Checks whether the node is, specifically, a pseudo element instead of
     * pseudo class.
     */
    function isPseudoElement(node: any): node is Pseudo;

    /**
     * Checks whether the node is, specifically, a pseudo class instead of
     * pseudo element.
     */
    function isPseudoClass(node: any): node is Pseudo;


    interface Tag extends Namespace {
        type: "tag";
    }
    function tag(opts: NamespaceOptions): Tag;
    function isTag(node: any): node is Tag;

    interface Comment extends Base {
        type: "comment";
    }
    function comment(opts: NodeOptions): Comment;
    function isComment(node: any): node is Comment;

    interface Identifier extends Base {
        type: "id";
    }
    function id(opts: any): Identifier;
    function isIdentifier(node: any): node is Identifier;

    interface Nesting extends Base {
        type: "nesting";
    }
    function nesting(opts?: any): Nesting;
    function isNesting(node: any): node is Nesting;

    interface String extends Base {
        type: "string";
    }
    function string(opts: NodeOptions): String;
    function isString(node: any): node is String;

    interface Universal extends Base {
        type: "universal";
    }
    function universal(opts?: NamespaceOptions): Universal;
    function isUniversal(node: any): node is Universal;
}
