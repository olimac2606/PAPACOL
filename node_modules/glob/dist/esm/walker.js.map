<?xml version="1.0" encoding="UTF-8"?>
<root>
    <Control FileName="sARunExists">
       <Text><![CDATA[セットアップは実行中のWondershare Recoveritを検出しました。Wondershare Recoveritを閉じてから「OK」をクリックしてください。]]></Text>
	</Control>
	<Control FileName="sBRunExists">
      <Text><![CDATA[セットアップは実行中のWondershare Recoverit の別のバージョンを検出しました。Wondershare Recoverit を閉じてから「OK」をクリックしてください。]]></Text>
	</Control>
	<Control FileName="sExistsHint">
      <Text><![CDATA[Wondershare Recoveritはパソコンにインストールされています。再度インストールしますか？]]></Text>
	</Control>
	<Control FileName="strOK">
      <Text><![CDATA[OK]]></Text>
	</Control>
	<Control FileName="strCancel">
      <Text><![CDATA[キャンセル]]></Text>
	</Control>
	<Control FileName="strYes">
      <Text><![CDATA[はい]]></Text>
	</Control>
	<Control FileName="strNo">
      <Text><![CDATA[いいえ]]></Text>
	</Control>
	<Control FileName="strAccept">
      <Text><![CDATA[同意]]></Text>
	</Control>
	<Control FileName="strNext">
      <Text><![CDATA[次へ]]></Text>
	</Control>
	<Control FileName="strBack">
      <Text><![CDATA[戻る]]></Text>
	</Control>
	<Control FileName="strInstall">
      <Text><![CDATA[インストール]]></Text>
	</Control>
	<Control FileName="strFinish">
      <Text><![CDATA[完了]]></Text>
	</Control>
	<Control FileName="strSelect">
      <Text><![CDATA[選択]]></Text>
	</Control>
	<Control FileName="strHint">
      <Text><![CDATA[言語を選択してください:]]></Text>
	</Control>
	<Control FileName="strTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 セットアップ]]></Text>
	</Control>
	<Control FileName="strExitHint">
      <Text><![CDATA[セットアップ作業は完了していません。ここでセットアップを中止するとプログラムはインストールされません。セットアップを終了しますか？]]></Text>
	</Control>
	<Control FileName="strLicensePageHint">
      <Text><![CDATA[以下の使用許諾契約書をお読みください。インストールを続行するにはこの契約書に同意する必要があります。]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng1">
      <Text><![CDATA[開始]]></Text>
	</Control>
	<Control FileName="strLicenseLiucheng2">
      <Text><![CDATA[注意 -> オプション -> インストール中 -> 完了]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng1">
      <Text><![CDATA[開始]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng2">
      <Text><![CDATA[-> ]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng3">
      <Text><![CDATA[注意]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng4">
      <Text><![CDATA[オプション -> インストール中 -> 完了]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5">
      <Text><![CDATA[削除されたファイルを含むドライブへのインストールを行わないようにしてください。データの上書きを防ぐため、この]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_1">
      <Text><![CDATA[ドライブ上の操作を行わないようにしてください。復元したいファイルがハードディスクにある場合は、リムーバブル]]></Text>
	</Control>
	<Control FileName="strInforBeforeLiucheng5_2">
      <Text><![CDATA[ディスクにインストールしてください。]]></Text>
	</Control>
	<Control FileName="strSetupExit">
      <Text><![CDATA[セットアップ作業は完了していません。ここでセットアップを中止するとプログラムはインストールされません。改めてインストールする場合は、もう一度セットアップを実行してください。セットアップを終了しますか？]]></Text>
	</Control>	
	<Control FileName="strSelect1">
      <Text><![CDATA[開始    注意]]></Text>
	</Control>
	<Control FileName="strSelect2">
      <Text><![CDATA[ ->        ->]]></Text>
	</Control>
	<Control FileName="strSelect3">
      <Text><![CDATA[ オプション]]></Text>
	</Control>
	<Control FileName="strSelect4">
      <Text><![CDATA[インストール中 -> 完了]]></Text>
	</Control>
	<Control FileName="strSelect5">
      <Text><![CDATA[保存先：]]></Text>
	</Control>
	<Control FileName="strSelect6">
      <Text><![CDATA[ブラウズ...]]></Text>
	</Control>
	<Control FileName="strSelect7">
      <Text><![CDATA[必要なディスク容量:]]></Text>
	</Control>
	<Control FileName="strSelect8">
      <Text><![CDATA[空き容量:]]></Text>
	</Control>
	<Control FileName="strSelect9">
      <Text><![CDATA[付加的なオプション]]></Text>
	</Control>
	<Control FileName="strSelect10">
      <Text><![CDATA[デスクトップ上にアイコンを作成する]]></Text>
	</Control>
    <Control FileName="strSelect11">
      <Text><![CDATA[クイック起動アイコンを作成する]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarningTitle">
      <Text><![CDATA[開始      注意     オプション]]></Text>
	</Control>	
	 <Control FileName="strDiskSpaceWarning">
      <Text><![CDATA[選択したパーティションの容量が十分ではありません。インストールするには、別のパーティションを選択してください。]]></Text>          
	</Control>	
	 <Control FileName="strDirDoesntExistTitle">
      <Text><![CDATA[フォルダが見つかりません。]]></Text>
	</Control>	
	 <Control FileName="strDirDoesntExist">
      <Text><![CDATA[フォルダは既に存在しています。再インストールしてもよろしいですか？]]></Text>       
	</Control>
	<Control FileName="strSelectPathTitle">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 セットアップ]]></Text>       
	</Control>
	<Control FileName="strSelectPathLabel">
      <Text><![CDATA[以下のリストからフォルダを選択して、[OK]をクリックしてください。]]></Text>       
	</Control>	
	<Control FileName="strInstall1">
      <Text><![CDATA[開始      注意     オプション']]></Text>
	</Control>	
	<Control FileName="strInstall2">
      <Text><![CDATA[ ->          ->                ->]]></Text>
	</Control>	
	<Control FileName="strInstall2_1">
      <Text><![CDATA[ ->          ->                     ->]]></Text>
	</Control>	
	 <Control FileName="strInstall3">
      <Text><![CDATA[インストール中]]></Text>
	</Control>	
	 <Control FileName="strInstall4">
      <Text><![CDATA[完了]]></Text>
	</Control>	
	 <Control FileName="strInstall5">
      <Text><![CDATA[ファイルを復元する！]]></Text>
	</Control>	
	 <Control FileName="strFinish1">
      <Text><![CDATA[開始      注意     オプション      インストール中]]></Text>
	</Control>	
	 <Control FileName="strFinish2">
      <Text><![CDATA[ ->         ->               ->                       ->]]></Text>
	</Control>	
	 <Control FileName="strFinish1_1">
      <Text><![CDATA[開始      注意     オプション    インストール中]]></Text>
	</Control>	
	 <Control FileName="strFinish2_1">
      <Text><![CDATA[ ->         ->                    ->                           ->]]></Text>
	</Control>	
	<Control FileName="strFinish3">
      <Text><![CDATA[完了]]></Text>
	</Control>	
	 <Control FileName="strFinish4">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 のセットアップが完了！]]></Text>
	</Control>	
	 <Control FileName="strFinish5">
      <Text><![CDATA[Wondershare Recoveritを実行する]]></Text>
	</Control>	
    <Control FileName="UnistallStrTitle">
      <Text><![CDATA[Wondershare Recoverit アンインストール]]></Text>
	</Control>
    <Control FileName="UnistallStrCloseProgram">
      <Text><![CDATA[Wondershare Recoverit は現在実行されている場合、閉じる前にそれをアンインストールしてください。]]></Text>
	</Control>
    <Control FileName="UnistallStrConform">
      <Text><![CDATA[Wondershare Recoverit その関連コンポーネントをすべて削除してもよろしいですか？]]></Text>
	</Control>
    <Control FileName="UnistallSOkCaption">
      <Text><![CDATA[はい]]></Text>
	</Control>
    <Control FileName="UnistallSNOCaption">
      <Text><![CDATA[いいえ]]></Text>
	</Control>
    <Control FileName="UnistallStrRetry">
      <Text><![CDATA[再試行]]></Text>
	</Control>
    <Control FileName="UnistallStrCancel">
      <Text><![CDATA[キャンセル]]></Text>
	</Control>
    <Control FileName="UnistallStrFinish">
      <Text><![CDATA[完了]]></Text>
	</Control>
    <Control FileName="UnistallStrMain1">
      <Text><![CDATA[Wondershare Recoverit 4.8.3 アンインストールされている状態です。]]></Text>
	</Control>
    <Control FileName="UnistallStrMain2">
      <Text><![CDATA[Wondershare Recoverit を削除しています。しばらくお待ちください。]]></Text>
	</Control>
    <Control FileName="UnistallStrMain3">
      <Text><![CDATA[Wondershare Recoveritをアンインストール中...]]></Text>
	</Control>	
	<Control FileName="UnistallStrMain4">
      <Text><![CDATA[WondershareRecoverit の削除に成功しました。関連ファイルが残っています。必要ない場合は手動で削除してください。]]></Text>
	</Control>
	<Control FileName="strNetLabel">
	   <Text><![CDATA[アップデートをダウンロードしています...]]></Text>
	</Control>
	<Control FileName="strNetFail">
	   <Text><![CDATA[アップデートが失敗しました。ネットワーク接続を確認してください。]]></Text>
	</Control>
	<Control FileName="sConvenienceHint">
			<Text><![CDATA[Recoveritで失われたデータを取り戻す]]></Text>
	</Control>
</root>
                                                                                                                     EAAE,CAAA;YAChC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,CAAA;QAChD,CAAC;QAED,IAAI,EAAE,CAAA;IACR,CAAC;IAED,WAAW,CACT,MAAY,EACZ,OAAe,EACf,SAAoB,EACpB,EAAa;QAEb,SAAS,GAAG,SAAS,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;QAEpD,IAAI,KAAK,GAAG,CAAC,CAAA;QACb,MAAM,IAAI,GAAG,GAAG,EAAE;YAChB,IAAI,EAAE,KAAK,KAAK,CAAC;gBAAE,EAAE,EAAE,CAAA;QACzB,CAAC,CAAA;QAED,KAAK,MAAM,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;YAC/D,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAAE,SAAQ;YAC9B,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAA;QACpC,CAAC;QACD,KAAK,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;YAC9D,KAAK,EAAE,CAAA;YACP,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,EAAE,SAAS,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,CAAA;QAC7D,CAAC;QAED,IAAI,EAAE,CAAA;IACR,CAAC;CACF;AAED,MAAM,OAAO,UAEX,SAAQ,QAAW;IACnB,OAAO,GAAG,IAAI,GAAG,EAAa,CAAA;IAE9B,YAAY,QAAmB,EAAE,IAAU,EAAE,IAAO;QAClD,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;IAC7B,CAAC;IAED,SAAS,CAAC,CAAY;QACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;IACrB,CAAC;IAED,KAAK,CAAC,IAAI;QACR,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO;YAAE,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;QAClD,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YAC1B,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAA;QACzB,CAAC;QACD,MAAM,IAAI,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE;gBACzC,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC;oBACzB,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;gBACzB,CAAC;qBAAM,CAAC;oBACN,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;gBACnB,CAAC;YACH,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACF,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;IAED,QAAQ;QACN,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO;YAAE,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;QAClD,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAA;QACvB,CAAC;QACD,4DAA4D;QAC5D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE;YAC7C,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO;gBAAE,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;QACpD,CAAC,CAAC,CAAA;QACF,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;CACF;AAED,MAAM,OAAO,UAEX,SAAQ,QAAW;IACnB,OAAO,CAAgC;IAEvC,YAAY,QAAmB,EAAE,IAAU,EAAE,IAAO;QAClD,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,QAAQ,CAAuB;YAChD,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,UAAU,EAAE,IAAI;SACjB,CAAC,CAAA;QACF,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAA;QAC7C,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAA;IAChD,CAAC;IAED,SAAS,CAAC,CAAY;QACpB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO;YAAE,IAAI,CAAC,KAAK,EAAE,CAAA;IACzC,CAAC;IAED,MAAM;QACJ,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAA;QACxB,IAAI,MAAM,CAAC,SAAS,EAAE,EAAE,CAAC;YACvB,MAAM,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;gBACvB,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;YAC9D,CAAC,CAAC,CAAA;QACJ,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;QAC9D,CAAC;QACD,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;IAED,UAAU;QACR,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAA;QACvB,CAAC;QACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;QACnE,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;CACF","sourcesContent":["/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n  includeChildMatches?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Path\n  : O extends GWOFileTypesFalse ? string\n  : O extends GWOFileTypesUnset ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Set<Path>\n  : O extends GWOFileTypesFalse ? Set<string>\n  : O extends GWOFileTypesUnset ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> = Minipass<\n  Result<O>,\n  Result<O>\n>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts,\n): IgnoreLike =>\n  typeof ignore === 'string' ? new Ignore([ignore], opts)\n  : Array.isArray(ignore) ? new Ignore(ignore, opts)\n  : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n  includeChildMatches: boolean\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    this.includeChildMatches = opts.includeChildMatches !== false\n    if (opts.ignore || !this.includeChildMatches) {\n      this.#ignore = makeIgnore(opts.ignore ?? [], opts)\n      if (\n        !this.includeChildMatches &&\n        typeof this.#ignore.add !== 'function'\n      ) {\n        const m = 'cannot ignore child matches, ignore lacks add() method.'\n        throw new Error(m)\n      }\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? await e.lstat() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath()\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat()\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return (\n        e &&\n          (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n          (!ifDir || e.canReaddir()) &&\n          (!this.opts.nodir || !e.isDirectory()) &&\n          (!this.opts.nodir ||\n            !this.opts.follow ||\n            !e.isSymbolicLink() ||\n            !e.realpathCached()?.isDirectory()) &&\n          !this.#ignored(e)\n      ) ?\n        e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? e.lstatSync() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync()\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync()\n      }\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    // we know we have an ignore if this is false, but TS doesn't\n    if (!this.includeChildMatches && this.#ignore?.add) {\n      const ign = `${e.relativePosix()}/**`\n      this.#ignore.add(ign)\n    }\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n          '.' + this.#sep\n        : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true,\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb),\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  matches = new Set<Result<O>>()\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Set<Result<O>>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Set<Result<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  results: Minipass<Result<O>, Result<O>>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass<Result<O>, Result<O>>({\n      signal: this.signal,\n      objectMode: true,\n    })\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n"]}