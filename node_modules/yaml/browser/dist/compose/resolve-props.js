}
  }
} exports.flowParseImportSpecifier = flowParseImportSpecifier;

// parse function type parameters - function foo<T>() {}
 function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
  }
} exports.flowStartParseFunctionParams = flowStartParseFunctionParams;

// parse flow type annotations on variable declarator heads - let foo: string = bar
 function flowAfterParseVarHead() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
} exports.flowAfterParseVarHead = flowAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
 function flowStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
} exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
 function flowParseMaybeAssign(noIn, isWithinParens) {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.type = _types.TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }

    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
    wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    _util.unexpected.call(void 0, );
  }

  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
} exports.flowParseMaybeAssign = flowParseMaybeAssign;

// handle return types for arrow functions
 function flowParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    const snapshot = _base.state.snapshot();

    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;

    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
    _index.popTypeContext.call(void 0, oldIsType);
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
} exports.flowParseArrow = flowParseArrow;

 function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&
    _index.match.call(void 0, _types.TokenType.lessThan)
  ) {
    const snapshot = _base.state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !_base.state.error) {
      return;
    }
    _base.state.restoreFromSnapshot(snapshot);
  }

  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
} exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _statement.parseFunctionParams.call(void 0, );
  if (!_expression.parseArrow.call(void 0, )) {
    return false;
  }
  _expression.parseArrowExpression.call(void 0, startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  _expression.parseIdentifier.call(void 0, );
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    _index.next.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  flowParseEnumMembers();
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseEnumMembers() {
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!_index.match.call(void 0, _types.TokenType.braceR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
}

funct