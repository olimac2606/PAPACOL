,
): Promise<T>;

export const timesSeries: typeof times;
export function timesLimit<T, E = Error>(
    n: number,
    limit: number,
    iterator: AsyncResultIterator<number, T, E> | AsyncResultIteratorPromise<number, T>,
    callback: AsyncResultArrayCallback<T, E>,
): void;
export function timesLimit<T, E = Error>(
    n: number,
    limit: number,
    iterator: AsyncResultIterator<number, T, E> | AsyncResultIteratorPromise<number, T>,
): Promise<T>;

export function transform<T, R, E = Error>(
    arr: T[],
    iteratee: (acc: R[], item: T, key: number, callback: (error?: E) => void) => void,
    callback?: AsyncResultArrayCallback<T, E>,
): void;
export function transform<T, R, E = Error>(
    arr: T[],
    acc: R[],
    iteratee: (acc: R[], item: T, key: number, callback: (error?: E) => void) => void,
    callback?: AsyncResultArrayCallback<T, E>,
): void;

export function transform<T, R, E = Error>(
    arr: { [key: string]: T },
    iteratee: (acc: { [key: string]: R }, item: T, key: string, callback: (error?: E) => void) => void,
    callback?: AsyncResultObjectCallback<T, E>,
): void;

export function transform<T, R, E = Error>(
    arr: { [key: string]: T },
    acc: { [key: string]: R },
    iteratee: (acc: { [key: string]: R }, item: T, key: string, callback: (error?: E) => void) => void,
    callback?: AsyncResultObjectCallback<T, E>,
): void;

export function rac